---
title: "STAT545_hw02_JLB"
output: github_document
---

#STAT 545 Homework 2

The different sections of this homework are broken down into the sections outlined in [the homework instructions](http://stat545.com/Classroom/assignments/hw02/hw02.html): 

**Homework 2 Task list: **  

1. [x] Getting Started: Install Gapminder & dyplyr  
2. [ ]Smell test the data: Explore the gapminder object  
3. [ ]Explore individual variables:  
4. [ ]Explore various plot types:   
5. [ ]Extra exercise:   
6. [ ]Conclusions and Reflection:  


### 1. Getting Started:   
Install/Load Gapminder and dyplyr (through the tidyverse package)
```{r}
library(gapminder)
library(tidyverse)
```


### 2. Smell test the data:
Explore the gapminder object:

**2a. Is it a dataframe, matrix, vector, list?**  
The typeof() function will tell me what data types gapminder contains.   
The class() function will tell me the class of the object gapminder.
```{r}
?gapminder
typeof(gapminder)
class(gapminder)
```
Conclusion: 
- Gapminder is a data frame that contains list data.

**2b. What is its class?**  
As shown above, we can use the class() function to determine the class of the gapminder object:
```{r}
(class(gapminder))
```
Conclusion: 
The class of gapminder is a data frame, specifically, a tibble (which we have not yet explored in class)

**2c. How many columns/variables?**
```{r}
(ncol(gapminder))
```
Conclusion: 
There are 6 variables in gapminder.

**2d. How many rows/observations?**
```{r}
(nrow(gapminder))
```
Conclusion: 
There are 1704 observations in gapminder.

**2e Can you get these facts about “extent” or “size” in more than one way? Can you imagine different functions being useful in different contexts?**  
I found additional information on how to further explore gapminder [here](http://adv-r.had.co.nz/Data-structures.html)
```{r}
?gapminder
length(gapminder) 
#attributes(gapminder)
```
Conclusion: 

a. using ?gapminder is another way to get information about gapminder such as format, names and types of variables in the object, and specific descriptions of each variable. 
context: This function is useful for getting a quick overview and understanding the data and where it comes from.

b. length(gapminder) returns the number of elements inside it, in this case, the number of variables. Another application of the length() function is to look at length of and array variable, allowing users to make a loop that repeats for each value in the array.

c. the attributes(gapminder) function is similar to summary(), but gives information about row names as well. In this context the row names are simply numbers 1, 2, 3, etc... (so, less useful), but in other contexts these names may be more informative. 


**2f What data type is each variable?**  
using the str() function allows us to look at the structure of the variables 
```{r}
str(gapminder)
#to double check the output of str(), I can check a variable individually:
class(gapminder$year)
```
Conclusion: 
The variables in gapminder are lists containing different datatypes:
country - factors
continent - factors
year - integers
lifeExp - numbers
pop - integers
gdpPercap - numbers

#### 3. Explore individual variables
Categorical variable selected: continent
Quantitative variable selected: gdpPercap

** 3a. Exploring possible values (or range, whichever is appropriate) of variables:**  

I can look at the range of GDP per capitda in the data:  
The min() function shows the lowest, while the max() function shows the highest GDP per Capita. The range() function gives both min and max as an output. 

```{r}
min(gapminder$gdpPercap)
max(gapminder$gdpPercap)
range(gapminder$gdpPercap)
```
**Conclusion:**  
the range of GDP per capitda in the gapminder dataset is $241-113 523.

Looking at the spread of values :
```{r}
#spread(gapminder, key,value)
```

I can also use the min(), max() and range() functions with the lifeExp, because it contains integers, however, this will not work for the country variable, as these functions do not apply.
```{r}
min(gapminder$lifeExp)
max(gapminder$lifeExp)
range(gapminder$lifeExp)

```
Conclusion: 
The range of life expectancies contained in the gapminder dataset is 23.6 - 82.6 years.

To look at the distribution of the continent variable:
```{r}
attributes(gapminder$continent)
```
These values seem typical, as they are representative of the world's continents.




SUMMARY TABLE:



Looking more closely at the country and lifeExp variables: 
```{r}
select(gapminder, country, year, lifeExp) %>% 
  filter(year == "2007") %>% 
  summary()
```

```{r}

```


####Explore various plot types
 useful [site](https://stackoverflow.com/questions/10438752/adding-x-and-y-axis-labels-in-ggplot2) for how to add axis labels and title for your ggplot

 - A scatterplot of two quantitative variables.

```{r}
#similar to how we saw filtering by a variable such as 'country' in class for geom_line, we can also do this to assign colours using colour = country. 

gapminder %>% 
  
  filter(country == "Canada"|country == "United States") %>% 
  ggplot(aes(x=year, y=pop)) + 
  geom_point() +
  geom_line(aes(filter = country,colour = country)) +
  xlab("Year") +
  ylab("Population of Canada and United States") +
  ggtitle("North American Population Trends")

  

```


```{r}
gapminder %>% 
  filter(country == "Canada" | country =="United States")%>% 
  ggplot(aes(x=year, y = gdpPercap)) +
  geom_line(aes(group = country, colour = country)) +
  geom_point() +
  xlab("Year") +
  ylab("GDP Per Capita") +
  ggtitle("North American GDP Per Capita Trends")
  
```



- A plot of one quantitative variable. Maybe a histogram or densityplot or frequency polygon.

```{r}
gapminder %>%
  filter (year == "2007") %>% 
  ggplot(aes(gdpPercap)) +
  geom_histogram(aes(y=..density..),bins = 35) + 
  geom_density(fill = "green", alpha = 0.2)


#looking more closely at the spread of density where gdpPercap is less than  5000:

gapminder %>% 
  filter (year == "2007" & gdpPercap < 5000) %>% 
  ggplot(aes(gdpPercap)) +
  geom_histogram(bins = 20)
 
#Table showing the 20 countries with the lowest GDP per capita in 2007, in ascending order. 
gapminder %>%
  filter (year == "2007") %>% 
  select (country, gdpPercap) %>% 
  top_n (-20) %>% 
  arrange(gdpPercap)

#Table showing the 20 countries with highest GDP per capita in 2007 in ascending order
gapminder %>%
  filter (year == "2007") %>% 
  select (country, gdpPercap) %>% 
  top_n (20) %>% 
  arrange(gdpPercap)

```



```{r}
gapminder %>%
  select(gdpPercap, continent) %>% 
  ggplot(aes(continent, gdpPercap)) +
  scale_y_log10() +
  geom_violin() +
  geom_jitter(alpha = 0.15) +
  xlab("Continent")+
  ylab("GDP Per Capita (log10)") +
  ggtitle("GDP Per Capita by Continent")
  
```

 - A plot of one quantitative variable and one categorical. Maybe boxplots for several continents or countries.
####Extra Exercise:






Instructions: Evaluate this code and describe the result. Presumably the analyst’s intent was to get the data for Rwanda and Afghanistan. Did they succeed? Why or why not? If not, what is the correct way to do this?
```{r}
#no they were not successful. 

filter(gapminder, country == c("Rwanda", "Afghanistan"))

#looking at the data that results from this code, the analyst's code returns 12 rows of data (8 for Rwanda, 8 for Afghanistan). 
#when I run the code below: 

gapminder %>% 
  filter (country =="Rwanda" | country == "Afghanistan")
#I get 24 rows of data. It appears that somehow, by concatenating the countries he wanted to collect data for, the analyst ommitted half of the rows. 

#why?
#When we use the combine function it will go row by row through the different countries
#it will compare row1 with "Rwanda"
#then it will compare row2 with "Afghanistan"
#Then it will start over and compare row 3 == "Rwanda", and if row 4 =="Afghanistan", etc. 
#If the result is TRUE, then it will add it to the tibble. 
#However, this means rows containing "Rwanda" will return FALSE if the code is currently comparing to "Afghanistan" and vice versa

#To test if this explanation is true, if I run the code below, I should obtain 8 rows with values for Rwanda, but only 4 for Afghanistan (note - this is only applicable for this dataset, as I know there are equal rows for Rwanda and Afghanistan, organized alphabetically. The result would be different for another dataset). 

filter(gapminder, country == c("Rwanda", "Afghanistan", "Rwanda"))

## Interestingly, I noticed that the length of the combined list must be divisible into the number of rows in the dataframe. 
#If I try to run the code below, it will return an error. 

#filter(gapminder, country == c("Rwanda", "Afghanistan", "Norway", "China", "Japan")) 

#The reason for this is because it must be able to fully cycle through the combined list, we cannot divide 5 into the number of rows of data in gapminder. 


#conclude: 
#a correct way to run the code is: 
gapminder %>% 
  filter (country =="Rwanda" | country == "Afghanistan")
```










